import XCTest
@testable import FlightSearch

class LoginViewTests: XCTestCase {

    func testValidEmail() {
        let loginView = LoginView()
        XCTAssertTrue(loginView.isValidEmail("test@example.com"))
        XCTAssertTrue(loginView.isValidEmail("firstname.lastname@domain.co.uk"))
        XCTAssertTrue(loginView.isValidEmail("email+alias@sub.domain.com"))
    }

    func testInvalidEmail() {
        let loginView = LoginView()
        XCTAssertFalse(loginView.isValidEmail("invalid-email"))
        XCTAssertFalse(loginView.isValidEmail("invalid@domain"))
        XCTAssertFalse(loginView.isValidEmail("@domain.com"))
        XCTAssertFalse(loginView.isValidEmail("test@.com"))
        XCTAssertFalse(loginView.isValidEmail("test@domain."))
    }

    func testPasswordValidation() {
        let loginView = LoginView()
        XCTAssertTrue(loginView.password.count >= 8, "Password should be at least 8 characters long. Current length: \(loginView.password.count)") // This test requires the password to be set externally or simulated.
        // In a real scenario, we'd likely test the loginUser() function with different states of email and password.
    }

    // Corner case: Empty email and password should disable login button
    func testLoginButtonDisabledWhenEmpty() {
        let loginView = LoginView()
        XCTAssertTrue(loginView.email.isEmpty)
        XCTAssertTrue(loginView.password.isEmpty)
        // We need to simulate the UI interaction to check button state, which is harder in pure unit tests without UI testing frameworks.
        // For a unit test, we can check the conditions that would lead to the button being disabled.
    }

    // Corner case: Long email and password
    func testLongInputFields() {
        let loginView = LoginView()
        let longEmail = String(repeating: "a", count: 254) + "@domain.com"
        let longPassword = String(repeating: "b", count: 100)
        XCTAssertTrue(loginView.isValidEmail(longEmail))
        XCTAssertTrue(loginView.password.count >= 8) // Similar to password validation, needs state manipulation.
    }

    // Corner case: Special characters in email (valid and invalid)
    func testSpecialCharactersInEmail() {
        let loginView = LoginView()
        XCTAssertTrue(loginView.isValidEmail("test.user+alias@example.com"))
        XCTAssertTrue(loginView.isValidEmail("user_name@domain.org"))
        XCTAssertFalse(loginView.isValidEmail("user name@domain.com")) // Space is invalid
        XCTAssertFalse(loginView.isValidEmail("user@domain..com")) // Double dot is invalid
    }

    // Add more tests for the simulated loginUser() function if it were more complex, e.g., testing API responses.
    // For example:
    // func testLoginSuccessSimulation() {
    //     let loginView = LoginView()
    //     loginView.email = "valid@example.com"
    //     loginView.password = "validpassword"
    //     loginView.loginUser() // This would need to be async and check a published property
    //     // XCTAssertTrue(loginView.isLoginSuccessful)
    // }
}
